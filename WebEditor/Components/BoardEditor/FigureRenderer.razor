@using CaptainCoder.TacticsEngine.Board
@using System.Diagnostics.CodeAnalysis
@inject ToolManager ToolManager
@if (IsVisible)
{
<div 
    class="figure-info"
    dragged="@AlwaysVisible"
    is-invalid="@IsInvalid"
    ignore-mouse="@IgnoreMouse"
    style="
        --pos-x: @(Figure.Position.X); 
        --pos-y: @(Figure.Position.Y);
        --figure-width: @(Figure.Element.Width);
        --figure-height: @(Figure.Element.Height);"
    @onmouseenter="@(() => OnMouseEnter.InvokeAsync(Figure.Position))"
    @onclick="@(() => ToolManager.SelectFigure(Board, Figure))"
    @onmousedown="@(() => _mouseDown = true)"
    @onmouseup="@(() => _mouseDown = false)"
    @onmousemove="@CheckDragStart"
    >
</div>
}

@code
{
    private bool _mouseDown = false;
    [Parameter, EditorRequired, AllowNull]
    public Positioned<Figure> Figure { get; set; }
    [CascadingParameter, AllowNull]
    public Board Board { get; set; }
    [CascadingParameter, AllowNull]
    public BoardRenderer Parent { get; set; }
    [Parameter]
    public EventCallback<Position> OnMouseEnter { get; set; }
    [Parameter]
    public bool AlwaysVisible { get; set; } = false;
    public bool IsVisible => AlwaysVisible || Board.Figures.Contains(Figure);
    public bool IgnoreMouse => FigureTool.Shared.DraggedFigure is not null;
    public bool IsInvalid
    {
        get
        {
            if (!AlwaysVisible) { return false; }
            if(Board.TryAddFigure(Figure.Position, Figure.Element))
            {
                Board.RemoveFigure(Figure.Position);
                return false;
            }
            return true;
        }
    }
    private void CheckDragStart(MouseEventArgs args)
    {
        if (_mouseDown)
        {
            Position offset = new (-(int)(args.OffsetX / Parent.CellSize), -(int)(args.OffsetY / Parent.CellSize));
            _mouseDown = false;
            ToolManager.StartDragFigure(Board, Figure, offset);
        }
    }

}